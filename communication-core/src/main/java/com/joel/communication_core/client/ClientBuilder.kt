package com.joel.communication_core.client

import com.joel.communication_core.alias.Header
import com.joel.communication_core.alias.Headers
import com.joel.communication_core.annotations.CommunicationsMarker
import com.joel.communication_core.cache.CacheBuilder
import com.joel.communication_core.client.interceptors.CustomHeaderInterceptor
import com.joel.communication_core.client.interceptors.LoggingInterceptor
import com.joel.communication_core.enums.HttpHeader
import com.joel.communication_core.enums.LogLevel
import com.joel.communication_core.exceptions.CommunicationsException
import okhttp3.Cache
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import java.security.KeyStore
import java.util.concurrent.TimeUnit
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLSocketFactory
import javax.net.ssl.TrustManager
import javax.net.ssl.TrustManagerFactory
import javax.net.ssl.X509TrustManager

@CommunicationsMarker
class ClientBuilder internal constructor() {
    private val headers: Headers = mutableListOf()
    private val timeoutBuilder = TimeoutBuilder()
    private val interceptors = mutableListOf<Interceptor>()
    private var cacheBuilder: CacheBuilder? = null

    init {
        val defaultHeaders = listOf(
            Header(HttpHeader.CONTENT_TYPE, "application/x-www-form-urlencoded"),
            Header(HttpHeader.ACCEPT, "application/json")
        )

        defaultHeaders.forEach {
            headers.add(it)
        }
    }

    /**
     * The base url of the request.
     * Should not be empty.
     */
    var baseUrl: String = ""

    var logLevel: LogLevel = LogLevel.None

    /**
     * Authorization header to to send in the http request for all calls.
     *
     * @param token The token generated by the api server.
     * @param prefix That is used to the header. Default is 'Bearer'.
     */
    fun authorization(token: String?, prefix: String = "Bearer") {
        if (hasHeader(HttpHeader.AUTHORIZATION).not()) {
            val header = Header(HttpHeader.AUTHORIZATION, "$prefix $token")
            headers.add(header)
        }
    }

    /**
     * The language that will be used in the server to get the response for all calls.
     *
     * @param languageCode Should have 2 characters only.
     * If you already sent the language, this will be ignored.
     */
    fun language(languageCode: String) {
        if (languageCode.length != 2)
            throw CommunicationsException("Language code must contains only 2 characters")

        if (hasHeader(HttpHeader.ACCEPT_LANGUAGE).not()) {
            val header = Header(HttpHeader.ACCEPT_LANGUAGE, languageCode)
            headers.add(header)
        }
    }

    /**
     * The [Header] object to send in the http request for all calls.
     *
     * @param header The header to send.
     */
    fun header(header: Header) {
        headers.add(header)
    }

    /**
     * Call this function to have access to the [TimeoutBuilder] and handle timeout times.
     *
     */
    fun timeout(builder: TimeoutBuilder. () -> Unit) {
        timeoutBuilder.also(builder)
    }

    /**
     * Add a new Interceptor to http
     */
    fun interceptor(interceptor: Interceptor) {
        this.interceptors.add(interceptor)
    }

    fun cache(builder: CacheBuilder. () -> Unit) {
        this.cacheBuilder = CacheBuilder().also(builder)
    }

    internal fun build(): Client {
        val cache = cacheBuilder?.build()
        val client = createClient(cache)
        return ClientImpl(client, baseUrl)
    }

    private fun hasHeader(key: HttpHeader) = headers.find { it.first == key } != null

    private fun createClient(cache: Cache?): OkHttpClient {
        val trustManagerFactory: TrustManagerFactory =
            TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
        trustManagerFactory.init(null as KeyStore?)
        val trustManagers: Array<TrustManager> = trustManagerFactory.trustManagers
        check(!(trustManagers.size != 1 || trustManagers[0] !is X509TrustManager)) {
            "Unexpected default trust managers:" + trustManagers.contentToString()
        }
        val trustManager: X509TrustManager = trustManagers[0] as X509TrustManager
        val sslContext: SSLContext = SSLContext.getInstance("SSL")
        sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
        val sslSocketFactory: SSLSocketFactory = sslContext.socketFactory
        val builder = OkHttpClient.Builder()
            .sslSocketFactory(sslSocketFactory, trustManager)
            .addDefaultInterceptor()
            .addInterceptor(CustomHeaderInterceptor(headers))

        cache?.let {
            builder.cache(it)
        }

        return builder.build()
    }

    private fun OkHttpClient.Builder.addDefaultInterceptor(): OkHttpClient.Builder {
        val loggingInterceptor = LoggingInterceptor().also {
            it.level = logLevel
        }

        addInterceptor(loggingInterceptor)

        interceptors.forEach {
            addInterceptor(it)
        }

        connectTimeout(timeoutBuilder.connectionTimeout.inWholeMilliseconds, TimeUnit.MILLISECONDS)
        readTimeout(timeoutBuilder.readTimeout.inWholeMilliseconds, TimeUnit.MILLISECONDS)
        writeTimeout(timeoutBuilder.writeTimeout.inWholeMilliseconds, TimeUnit.MILLISECONDS)
        return this
    }
}